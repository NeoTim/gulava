/*
 *  Copyright (c) 2015 The Gulava Authors
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */
package gulava.processor;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.processing.Messager;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;

/**
 * Creates goal expressions, which can be separated into clause and predicate expressions. Several
 * clause expressions are disj'd together to form a predicate. In other words, each clause that a
 * predicate holds is an alternative way to satisfy the predicate.
 */
public final class GoalExpressions {
  private final String clauseInstance;

  /**
   * Used to generate unique identifiers for "bound" logic values which are instantiated in
   * preparation statements
   */
  private final Gensymer boundIds;

  private final Messager messager;

  /**
   * @param clauseInstance the object on which clause methods are invoked. This can correspond to a
   *     class name if the clause methods are static.
   * @param messager where to print error messages
   */
  public GoalExpressions(String clauseInstance, Messager messager) {
    this.clauseInstance = clauseInstance;
    this.boundIds = new Gensymer("__bound%s__");
    this.messager = messager;
  }

  public PreparedExpression predicate(Iterable<ExecutableElement> clauseMethods) {
    List<String> preparationStatements = new ArrayList<>();
    List<String> subGoalExpressions = new ArrayList<>();

    for (ExecutableElement clauseMethod : clauseMethods) {
      PreparedExpression clause = clause(clauseMethod);
      preparationStatements.addAll(clause.getPreparationStatements());
      subGoalExpressions.add(clause.getExpression());
    }

    return new PreparedExpression(
        Processors.compoundGoal("disj", subGoalExpressions), preparationStatements);
  }

  /**
   * Writes an <em>inline</em> goal factory method. A normal (non-inline) factory method creates
   * a goal which simply stores the arguments passed to the factory method and does not do any more
   * work (e.g. call {@code conj} or {@code disj}) until {@code run} is called. An inline factory
   * method, which eagerly constructs a compound goal with {@code disj} et al, can generally be used
   * wherever a normal one is used. Note that inline goal factory methods never call themselves
   * recursively, otherwise there would be a {@link StackOverflowError} when constructing the
   * {@code Goal}. As such, the inline method generated by this method will delegate to clause
   * methods, and the clause methods should <em>not</em> use the inline method, but should use a
   * goal which lazily calls the inline method upon being run.
   *
   * @param writer where to write the method signature and source to
   * @param modifiers modifiers to attach before the return type, such as {@code "public static"}
   * @param name the name of the method
   * @param clauseMethods the clauses to construct the goal based on
   */
  public void writeInlineMethod(
      Writer writer, String modifiers, String name, List<ExecutableElement> clauseMethods,
      Parameters parameters) throws IOException {
    writer.write("  " + modifiers + " " + ClassNames.GOAL + " " + name + "("
        + parameters + ") {\n");
    PreparedExpression predicate = predicate(clauseMethods);
    predicate.writePreparationStatements(writer);
    writer.write("    return " + predicate.getExpression() + ";\n");
    writer.write("  }\n");
  }

  /**
   * Generates the expression for the invocation of a certain clause required by a predicate method
   * implementation. A predicate method needs at least one clause to be valid - each clause
   * represents an alternative way to reach the goal. This means each clause invocation should be
   * disj'd together to create the final {@code Goal}.
   *
   * <p>The {@code getExpression()} value of the returned instance is a conj of the goal expressions
   * which fulfill this clause. This includes the clause invocation itself as well as "same()"
   * (unification) goals which unify the Object reference given to the goal factory method with the
   * kind of reference required by the clause method.
   */
  private PreparedExpression clause(ExecutableElement clauseMethod) {
    // The actual arguments to pass to the clause method. If the clause method accepts
    // "Object" for an argument, this can just be the same value passed to the predicate
    // method.
    List<String> decomposedArgList = new ArrayList<>();

    List<String> subGoals = new ArrayList<>();
    List<String> preparationStatements = new ArrayList<>();

    for (VariableElement parameter : clauseMethod.getParameters()) {
      TypeMirror parameterType = parameter.asType();
      String parameterName = parameter.getSimpleName().toString();

      if ((parameterType instanceof DeclaredType)
          && Processors.qualifiedName((DeclaredType) parameterType)
              .contentEquals("java.lang.Object")) {
        // No need to decompose because the clause method accepts an Object reference.
        decomposedArgList.add(parameterName);
      } else if (new IsPassThroughType().visit(parameterType)) {
        // This is a primitive type. Just pass it through unaltered.
        decomposedArgList.add(parameterName);
      } else {
        // We need to decompose this argument. Unify the Object reference passed to the goal
        // factory method to a reference of the desired type.
        String boundId = boundIds.gensym();
        decomposedArgList.add(boundId);
        String fresh = new FreshInstantiation(parameter, messager)
            .visit(parameterType);

        preparationStatements.add(
            String.format("    %s %s = %s;\n", parameterType, boundId, fresh));
        subGoals.add(String.format("%s.same(%s, %s)", ClassNames.GOALS, boundId, parameterName));
      }
    }

    // subGoals already has all the unification goals needed, if any. Now just add the
    // delegation to the clause method.
    if (clauseMethod.getReturnType().getKind() != TypeKind.VOID) {
      subGoals.add(
          String.format("%s.%s(%s)",
              clauseInstance,
              clauseMethod.getSimpleName(),
              Processors.join(", ", decomposedArgList)));
    }

    return new PreparedExpression(Processors.compoundGoal("conj", subGoals), preparationStatements);
  }
}
